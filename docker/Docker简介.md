### Docker 简介

#### **一、Docker是什么？** 

+ Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。

#### **二、Docker优点**

+ 持续集成
 >  **Docker可以通过确保从开发到产品发布整个过程环境的一致性。保持容器内部所有的配置和依赖关系始终不变。最终，你可以在开发到产品发布的整个过程中使用相同的容器来确保没有任何差异或者人工干预。**
 *(这些差异可能是由于不同安装包的版本和依赖关系引起的,在开发与发布的生命周期中，不同的环境具有细微的不同)*

+ 版本控制
 > **Docker容器还可以像git仓库一样,可以让你提交变更到Docker镜像中并通过不同的版本来管理它们,Docker可以让你像git一样的轻松地回滚到这个镜像的前一个版本。这整个过程可以在几分钟内完成，如果和虚拟机的备份或者镜像创建流程对比，那Docker算相当快的，它可以让你快速地进行复制和实现冗余。此外，启动Docker就和运行一个进程一样快几乎是秒级启动！！！**

+ 可移植性
 > **Docker能够确保每个容器都拥有自己的资源，并且和其他容器是隔离的。如果你不在需要一款应用程序，那你可以简单地通过删除容器来删除这个应用程序，并且在你的宿主机操作系统上不会留下任何的临时文件或者配置文件,也就是各个程序都是相互隔离在一个容器内，这就大大增加了移植性，移植过程中不会留下临时文件等复杂的依赖，完全隔离移植！**

+ 隔离性和安全性
 > **Docker将宿主机操作系统上的敏感挂载点（例如/proc和/sys）作为只读挂载点，并且使用一种写时复制系统来确保容器不能读取其他容器的数据,由于Docker容器是隔离的，并且资源是受限制的，所以即使你其中一个应用程序被黑，也不会影响运行在其它Docker容器上的应用程序。从安全角度来看，Docker确保运行在容器中的应用程序和其他容器中的应用程序是完全分隔与隔离的，在通信流量和管理上赋予你完全的控制权。Docker容器不能窥视运行在其他容器中的进程。从体系结构角度来看，每个容器只使用着自己的资源（从进程到网络堆栈）**

##### Docker与传统的虚拟化技术相比。
| 特性 | 容器 | 虚拟机 |
| :----:| :----: | :----: |
| 启动 | 秒级 | 分钟级 |
| 硬盘使用 | 一般 MB | 一般 GB |
| 性能 | 接近原生 | 弱 |
| 系统支持量 | 单机支持上千个容器 | 一般几十个 |

**Docker相比传统虚拟化技术的优势**
 > + 更高效的系统资源利用
 > + 更快速的启动时间
 > + 一致的运行环境
 > + 持续交付和部署
 > + 更轻松的迁移
 > + 更轻松的维护和拓展
 
#### **三、Docker的组成部分？** 

1. DockerClient客户端
 > **DockerClient客户端主要从两方面: 创建与命令执行**
 > 1. 分析如何创建一个Docker Client。并收集Docker Client所需的配置信息
 > 2. 分析Docker Client如何执行具体的请求命令，最终将请求发送至Docker Server。

2. Docker Daemon守护进程
 > **Docker Daemon是Docker架构中运行在后台的守护进程，大致可以分为Docker Server、Engine和Job三部分。**
 > + Docker Daemon可以认为是通过Docker Server模块接受Docker Client的请求，并在Engine中处理请求，然后根据请求类型，创建出指定的Job并运行，运行过程的作用有以下几种可能：
 > + 向Docker Registry获取镜像，通过graphdriver执行容器镜像的本地化操作，通过networkdriver执行容器网络环境的配置，通过execdriver执行容器内部运行的执行工作等。

3. Docker Image镜像
 > **在 Docker 里，一个只读层被称为镜像，一个镜像是永久不会变的。**
 > + 由于 Docker 使用一个统一文件系统，Docker 进程认为整个文件系统是以读写方式挂载的。 但是所有的变更都发生顶层的可写层，而下层的原始的只读镜像文件并未变化。由于镜像不 可写，所以镜像是无状态的
 > + 每一个镜像都可能依赖于由一个或多个下层的组成的另一个镜像。我们有时说，下层那个 镜像是上层镜像的父镜像
 > + 一个没有任何父镜像的镜像，谓之基础镜像。

4. DockerContainer容器
 > **要有Container首先要有Image，也就是说Container是通过image创建的。**
 > + Container是在原先的Image之上新加的一层，称作Container layer，这一层是可读可写的（Image是只读的）。
 > + 在面向对象的编程语言中，有类跟对象的概念。类是抽象的，对象是类的具体实现。Image跟Container可以类比面向对象中的类跟对象，Image就相当于抽象的类，Container就相当于具体实例化的对象。
 > + Image跟Container的职责区别：Image负责APP的存储和分发，Container负责运行APP

#### **四、底层原理**

*docker是一个client-server结构的系统，docker守护进程运行在主机上，然后通过socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。容器，是一个运行时的环境，就是我们说的集装箱。*

**1. docker利用的是宿主机的内核，而不需要guest os。因此当建立一个容器时，docker不需要和虚拟机一样重新加载一个操作系统的内核。从而避免加载操作系统内核返回比较费时的资源过程，当新建一个虚拟机时，虚拟机软件需要加载guest os，返回新建过程是分钟级的。而docker由于直接利用宿主机的操作系统，则省略了加载过程，因此新建一个docker容器只需要几秒。**

**2. docker有着比虚拟机更少的抽象层。由于docker不需要hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的是实际物理机的硬件资源。因此在cpu、内存利用率上docker将会在效率上有明显的而优势**







